# Web Exploitation

## picoCTF Insp3ct0r

Flag is in the source code (ctrl u) of the web page.

## picoCTF FindMe

curl -vL -d 'username=test&password=test!' URL

Burpsuite capture the response to the login

## picoCTF More SQLi

The challenge name tells us one thing: this will be related to SQL injection. We start the instance, and because it's a web exploitation challenge, we open up Burpsuite. We are greeted with a login page.

We activate Burpsuite intercept and its proxy. We send a sample login request and capture the request. Burpsuite provides a handy "intruder" feature, which allows us to send payloads in a specific part of a request. We send the request to intruder, clear the auto-detected payloads, and tell Burpsuite that the test for "username" is our payload. We switch over to the "payload" section, and we want to pick a wordlist of potential payloads. I used /usr/share/seclists/SQLi/quick-SQLi.txt

## picoCTF Match Regex

We are given a website. The first thing we should do is check the website's source code. Inside, we find an interesting JavaScript code snippet. 

```
<script>
	function send_request() {
		let val = document.getElementById("name").value;
		// ^p.....F!?
		fetch(`/flag?input=${val}`)
			.then(res => res.text())
			.then(res => {
				const res_json = JSON.parse(res);
				alert(res_json.flag)
				return false;
			})
		return false;
	}

</script>
```

There's a field for input text, and when we enter seemingly anything, it returns an error message for "wrong match! try again!". 
It seems to be running some sort of check. However, we are more interested in the comment. It is a regular expression phrase. 

We seemingly have enough to know the angle. Given that the name of the challenge is to "Match Regex", it's a logical assumption that we must create a phrase that matches some regular expression, probably the one leaked in the source code.

https://regex101.com/

This is a useful tool, since it allows us to enter a regular expression query, and test phrases against it. It's important to note the regex phrase is ```^p.....F!?```. We ignore the ```//```, since it is a JavaScript comment.

We can use the website to analyze the phrase - which looks like this

^ indicates the start of the expression. The 'p' will match to a 'p'. Each '.' will match any character. The '!' will match a '!' character. The `?` will match optionally, which means that something could exist there, but it's not mandatory.

Therefore a matching phrase would be ```p12345F!?```. Submitting this returns us the flag.

## picoCTF SOAP

At the top of the challenge, we already have a hint in the name: XXE (external entity injection), and the name is SOAP. We do some googling, and the angle here is definitely an XML XXE attack.

To perform an XML XXE attack, we first need to capture some sort of post request. If we play around on the web page, we find that clicking on "details" generates a post request.

```
<?xml version="1.0" encoding="UTF-8"?>
	<data>
		<ID>2
		</ID>
</data>
```

https://portswigger.net/web-security/xxe

This website has a good guide on how to perform an XXE attack.

To do so, we need to modify the above request in two ways: define an XXE object, such that it loads the password file, and actually call the variable to be displayed.
```
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>

<data><ID>&xxe;</ID></data>
```

We modified the POST request that we captured in two ways: we defined an XXE object, and we made it so that command is loaded and called inbetween the ```<ID>``` tags, where the ID would normally go. If we send this payload to the server, in our request, instead of the ID 1, we actually get returned the contents of the file we specified: /etc/passwd. Within the /etc/passwd file is the flag.